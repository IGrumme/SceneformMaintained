package com.google.ar.sceneform.lights

import android.content.res.AssetManager
import com.google.android.filament.*
import com.google.android.filament.utils.*
import com.google.ar.core.ArImage
import com.google.ar.core.Config
import com.google.ar.core.Frame
import com.google.ar.core.LightEstimate
import com.google.ar.sceneform.Scene
import com.google.ar.sceneform.extensions.*
import com.google.ar.sceneform.extensions.Filament
import com.google.ar.sceneform.utilities.use
import com.google.ar.sceneform.utilities.useBuffer
import java.nio.ByteBuffer
import kotlin.math.ln
import kotlin.math.max

const val defaultIblName = "environments/default_environment_ibl.ktx"
const val defaultSkyboxName = "environments/default_environment_skybox.ktx"

/**
 * Default Filament indirect light intensity for default camera exposure
 */
const val defaultIndirectIntensity = 30_000.0f

/**
 * Default sun directional light intensity
 */
const val defaultDirectionalIntensity = 100_000.0f

open class EnvironmentLights private constructor(val scene: Scene) {

    private val renderer get() = scene.renderer!!
    private val engine: Engine get() = Filament.engine
    private val lightManager get() = engine.lightManager

    private var baseIndirectLight: IndirectLight? = null
        set(value) {
            field = value
            indirectLight = value
            indirectIntensity = value?.intensity ?: defaultIndirectIntensity
            baseReflections = value?.reflectionsTexture
        }

    /**
     * IndirectLight (replaces LightProbe) for the scene, this affects reflections and indirect
     * lighting.
     * Defines the lighting environment for the scene
     * The fully loaded IndirectLight to be used as the lighting environment.
     */
    private var indirectLight: IndirectLight? = null
        set(value) {
            renderer.setIndirectLight(value)
            // baseIndirectLight could be reuse
            field?.takeIf { it != baseIndirectLight }?.destroy()
            field = value
        }

    private var baseDirectionalLight: LightManager.Builder? = null
        set(value) {
            field = value
            directionalLight = value?.build()
            directionalIntensity = directionalLight?.intensity ?: defaultDirectionalIntensity
        }

    /**
     * Represents the "sun" / the default directional light in the scene.
     */
    @Entity
    var directionalLight: Light? = null
        set(value) {
            if (field != value) {
                field?.let {
                    renderer.removeLight(it)
                    it.destroy()
                }
                value?.let { renderer.addLight(it) }
                field = value
            }
        }

    /**
     * Modulate the base intensity of the indirect environment light.
     * This value will be lowered or upped depending on the ARCore light estimate.
     * This parameter specifies the illuminance in lux (or lumen/m^2).
     * Default is 30,000 lux.
     */
    var indirectIntensity: Float = defaultIndirectIntensity
        set(value) {
            if (field != value) {
                field = value
                indirectLight?.intensity = value
            }
        }

    /**
     * Modulate the base intensity of the directional environment light.
     * Mostly used for shadowing.
     * This value will be lowered or upped depending on the ARCore light estimate.
     * This parameter specifies the illuminance in lux (or lumen/m^2).
     * By default, the sun's illuminance is used : 100,000 lux.
     */
    var directionalIntensity: Float = defaultDirectionalIntensity
        set(value) {
            if (field != value) {
                field = value
                directionalLight?.intensity = value
            }
        }

    private var baseReflections: Texture? = null
    private var baseSphericalHarmonics: FloatArray? = null

    /**
     * Sets the Skybox. The Skybox is drawn last and covers all pixels not touched by geometry.
     * The Skybox to use to fill untouched pixels, or null to unset the Skybox.
     */
    var skybox: Skybox? = null
        set(value) {
            field = value
            renderer.setSkybox(value)
        }

    private var lightEstimationMode = Config.LightEstimationMode.DISABLED
        set(value) {
            if (field != value) {
                field = value
                when (value) {
                    Config.LightEstimationMode.DISABLED -> {
                        indirectLight = baseIndirectLight
                        directionalLight = baseDirectionalLight?.build()
                    }
                    else -> {}
                }
            }
        }

    /**
     * Use the environment cubemap generated by ARCore or the static one defined by the base
     * indirect light
     */
    var useEnvironmentalHdrCubemap = true

    @JvmOverloads
    constructor(
        scene: Scene,
        indirectLight: IndirectLight,
        skybox: Skybox? = null,
        sphericalHarmonics: FloatArray? = null,
        directionalLight: LightManager.Builder? = LightManager
            .Builder(LightManager.Type.DIRECTIONAL)
            // Filament recommended intensity for natural sun light
            .intensity(defaultDirectionalIntensity)
            .castShadows(true)
    ) : this(scene) {
        this.baseIndirectLight = indirectLight
        this.skybox = skybox
        this.baseSphericalHarmonics = sphericalHarmonics
        this.baseDirectionalLight = directionalLight
    }

    @JvmOverloads
    constructor(
        scene: Scene,
        assetManager: AssetManager,
        iblName: String = defaultIblName,
        skyboxName: String? = null,
    ) : this(scene = scene,
        indirectLight = assetManager.open(iblName).useBuffer { buffer ->
            KTXLoader.createIndirectLight(Filament.engine, buffer).apply {
                intensity = defaultIndirectIntensity
            }
        },
        sphericalHarmonics = assetManager.open(iblName).useBuffer { buffer ->
            KTXLoader.getSphericalHarmonics(buffer.rewind())
        },
        skybox = skyboxName?.let {
            assetManager.open(skyboxName).useBuffer { buffer ->
                KTXLoader.createSkybox(Filament.engine, buffer)
            }
        }
    )

    fun setSessionConfig(config: Config) {
        lightEstimationMode = config.lightEstimationMode
    }

    /**
     * This is used by AR Sceneform scenes internally to adjust lighting based on values from
     * ARCore. An AR scene will call this automatically, possibly overriding other settings. In most
     * cases, you should not need to call this explicitly.
     *
     * @param colorCorrection modulates the lighting color of the scene.
     * @param pixelIntensity  modulates the lighting intensity of the scene.
     */
    fun doFrame(frame: Frame) {
        if (frame.lightEstimate.state != LightEstimate.State.VALID) {
            return
        }

        when (lightEstimationMode) {
            Config.LightEstimationMode.AMBIENT_INTENSITY -> {
                frame.lightEstimate?.let { lightEstimate ->
                    indirectLight = IndirectLight.Builder().apply {
                        baseReflections?.let {
                            reflections(it)
                        }
                        // Sets light estimate to modulate the scene lighting and intensity.
                        // The rendered lights will use a combination of these values and the color
                        // and intensity of the lights. A value of a white colorCorrection and
                        // pixelIntensity of 1 mean that no changes are made to the light settings.
                        FloatArray(4).apply {
                            lightEstimate.getColorCorrection(this, 0)
                        }.let { (redCorrection, greenCorrection, blueCorrection, pixelIntensity) ->
                            // Scale and bias the estimate to avoid over darkening.
                            // Modulates ambient color with modulation factor. irradianceData must
                            // have at least one vector of three floats.
                            baseSphericalHarmonics?.let {
                                irradiance(3, floatArrayOf(*it).apply {
                                    this[0] *= redCorrection
                                    this[1] *= greenCorrection
                                    this[2] *= blueCorrection
                                })
                            }
                            // Rendering in linear space, first convert this value to linear space
                            // by rising to the power 2.2.
                            // Normalize the result by dividing it by 0.18, which is middle gray in
                            // linear space.
                            val linearIntensity = pow(pixelIntensity, 2.2f) / 0.18f
                            intensity(indirectIntensity * linearIntensity)
                        }
                    }.build(Filament.engine)
                }
            }
            Config.LightEstimationMode.ENVIRONMENTAL_HDR -> {
                frame.lightEstimate?.let { lightEstimate ->
                    //TODO : Calculate an exposure scale from the actual Filament Camera settings
//                    val exposureScale = 1 / scene.renderer!!.exposure
                    indirectLight = IndirectLight.Builder().apply {
                        intensity(indirectIntensity)
                        if (useEnvironmentalHdrCubemap) {
                            lightEstimate.acquireEnvironmentalHdrCubeMap()?.use { cubemap ->
                                reflections(cubemap.toTexture())
                            }
                        } else {
                            baseReflections?.let { reflections(it) }
                        }
                        lightEstimate.environmentalHdrAmbientSphericalHarmonics?.let { sphericalHarmonics ->
                            irradiance(
                                3,
                                sphericalHarmonics.mapIndexed { index, sphericalHarmonic ->
                                    // TODO : Check if we still got to swap those indexes
                                    //  SH coefficients are not in the same order in Filament and Environmental HDR.
                                    //  SH coefficients at indices 6 and 7 are swapped between the two implementations.
                                    //  val filamentIndex = ENVIRONMENTAL_HDR_TO_FILAMENT_SH_INDEX_MAP[index/3]
                                    //  hdrSphericalHarmonics[filamentIndex*3 + (index%3)] *
                                    //      ENVIRONMENTAL_HDR_TO_FILAMENT_SH_COEFFICIENTS[filamentIndex] * exposureScale
                                    sphericalHarmonic * SPHERICAL_HARMONICS_RECONSTRUCTION_FACTORS[index / 3]
                                }.toFloatArray()
                            )
                        }
                    }.build(Filament.engine)

                    frame.lightEstimate.environmentalHdrMainLightDirection.let { (x, y, z) ->
                        // TODO (or not):
                        //  If light is detected as shining up from below, we flip the Y
                        //  component so that we always end up with a shadow on the ground to
                        //  fulfill UX requirements.
                        directionalLight?.direction = Direction(-x, -y, -z)
                    }

                    frame.lightEstimate.environmentalHdrMainLightIntensity.let { (r, g, b) ->
                        val rgbIntensity = Color(r, g, b)
                        // Scale hdr rgb values to fit in range [0, 1).
                        val intensityScale = 1 / max(1.0f, max(rgbIntensity))
                        val lightColor = rgbIntensity / intensityScale
                        directionalLight?.color = Color(lightColor.r, lightColor.g, lightColor.b)

                        // Convert from environmental hdr's relative value to lux for filament
                        // using base intensity value.
                        directionalLight?.intensity =
                            directionalIntensity * intensityScale //* exposureScale
                    }
                }
            }
            else -> {}
        }
    }

    /**
     * Destroys the EnvironmentLights and frees all its associated resources.
     */
    fun destroy() {
        baseIndirectLight?.destroy()
        baseIndirectLight = null
        baseReflections?.destroy()
        baseReflections = null
        indirectLight?.destroy()
        indirectLight = null
        directionalLight?.destroy()
        directionalLight = null
        skybox?.destroy()
        skybox = null
    }

    companion object {

        // Convert Environmental HDR's spherical harmonics to Filament spherical harmonics.
        // This conversion is calculated to include the following:
        //  - pre-scaling by SH basis normalization factor [shader optimization]
        //  - sqrt(2) factor coming from keeping only the real part of the basis [shader optimization]
        //  - 1/pi factor for the diffuse lambert BRDF [shader optimization]
        //  - |dot(n,l)| spherical harmonics [irradiance]
        //  - scaling for convolution of SH function by radially symmetrical SH function [irradiance]
        //
        // ENVIRONMENTAL_HDR_TO_FILAMENT_SH_INDEX_MAP must be applied change ordering of coeffients
        // from Environmental HDR to filament.
        private val SPHERICAL_HARMONICS_RECONSTRUCTION_FACTORS =
            floatArrayOf(
                0.282095f, -0.325735f, 0.325735f,
                -0.325735f, 0.273137f, -0.273137f,
                // notice index 6 & 7 swapped
                0.078848f, -0.273137f, 0.136569f
            )

        // SH coefficients are not in the same order in Filament and Environmental HDR.
        // SH coefficients at indices 6 and 7 are swapped between the two implementations.
//        private val ENVIRONMENTAL_HDR_TO_FILAMENT_SH_INDEX_MAP = intArrayOf(
//            0, 1, 2, 3, 4, 5, 7, 6, 8
//        )
    }
}

//TODO : Use the IBLPrefilterContext
// IBLPrefilterContext takes a 2D texture in parameter
// Determine how to create the 2D texture from the ARCore CubeMap
//    val context = IBLPrefilterContext(engine)
//    IBLPrefilterContext.EquirectangularToCubemap(context)
//        .run(cubeMapTexture)?.let { skyboxTexture ->
//            IBLPrefilterContext.SpecularFilter(context)
//                .run(skyboxTexture)?.let { reflectionsTexture ->
//                    reflections(reflectionsTexture)
//                }
//        }
//    engine.destroyTexture(cubeMapTexture)
fun Array<ArImage>.toTexture(): Texture {
    val cubemapFaceCount = 6
    val rgbChannelCount = 3
    val bytesPerFloat16 = 2
    val rgbaBytesPerPixel = 4 * 2
    val rgbBytesPerPixel = 3 * 2

    val width = this[0].width
    val height = this[0].height
    val bufferCapacity =
        width * height * cubemapFaceCount * rgbChannelCount * bytesPerFloat16
    val cubemapBuffer = ByteBuffer.allocate(bufferCapacity)
    val faceOffsets = IntArray(cubemapFaceCount) { index ->
        cubemapBuffer.position().also {
            val rgbaBuffer = this[index].planes[0].buffer
            while (rgbaBuffer.hasRemaining()) {
                for (byteIndex in 0 until rgbaBytesPerPixel) {
                    val byte = rgbaBuffer.get()
                    if (byteIndex < rgbBytesPerPixel) {
                        cubemapBuffer.put(byte)
                    }
                }
            }
        }
    }
    cubemapBuffer.flip()
    val levels = (1 + ln(width.toDouble()) / ln(2.0)).toInt()
    return Texture.Builder()
        .width(width)
        .height(height)
        .levels(levels)
        .sampler(Texture.Sampler.SAMPLER_CUBEMAP)
        .format(Texture.InternalFormat.R11F_G11F_B10F)
        .build(Filament.engine)
        .apply {
            generatePrefilterMipmap(Filament.engine,
                Texture.PixelBufferDescriptor(
                    cubemapBuffer,
                    Texture.Format.RGB,
                    Texture.Type.HALF
                ),
                faceOffsets,
                Texture.PrefilterOptions().apply {
                    mirror = false
                })
        }
}